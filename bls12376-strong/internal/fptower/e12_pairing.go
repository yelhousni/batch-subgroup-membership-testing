package fptower

func (z *E12) nSquare(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquare(z)
	}
}

func (z *E12) nSquareCompressed(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquareCompressed(z)
	}
}

// Expt set z to x^t in E12 and return z (t is the generator of the curve)
func (z *E12) Expt(x *E12) *E12 {
	/*
		// Expt computation is derived from the addition chain:
		//
		//	_10    = 2*1
		//	_11    = 1 + _10
		//	_110   = 2*_11
		//	_111   = 1 + _110
		//	_1110  = 2*_111
		//	_1111  = 1 + _1110
		//	i27    = ((_1111 << 8 + _111) << 9 + _1111) << 2
		//	i37    = ((_11 + i27) << 3 + 1) << 4 + _11
		//	return   i37 << 33 + 1
		//
		// Operations: 62 squares 9 multiplies
		//
		// Generated by github.com/mmcloughlin/addchain v0.4.0.

		// Allocate Temporaries.
		var result E12
		var (
			t0 = new(E12)
			t1 = new(E12)
		)

		// Step 1: &result = x^0x2
		result.CyclotomicSquare(x)

		// Step 2: &result = x^0x3
		result.Mul(x, &result)

		// Step 3: t0 = x^0x6
		t0.CyclotomicSquare(&result)

		// Step 4: t1 = x^0x7
		t1.Mul(x, t0)

		// Step 5: t0 = x^0xe
		t0.CyclotomicSquare(t1)

		// Step 6: t0 = x^0xf
		t0.Mul(x, t0)

		// Step 14: t2 = x^0xf00
		t2 := t0
		t2.nSquare(9)

		// Step 15: t1 = x^0xf07
		t1.Mul(t1, t2)

		// Step 24: t1 = x^0x1e0e00
		t1.nSquare(9)

		// Step 25: t0 = x^0x1e0e0f
		t0.Mul(t0, t1)

		// Step 27: t0 = x^0x78383c
		t0.nSquare(2)

		// Step 28: t0 = x^0x78383f
		t0.Mul(&result, t0)

		// Step 31: t0 = x^0x3c1c1f8
		t0.nSquare(3)

		// Step 32: t0 = x^0x3c1c1f9
		t0.Mul(x, t0)

		// Step 36: t0 = x^0x3c1c1f90
		t0.nSquare(4)

		// Step 37: &result = x^0x3c1c1f93
		result.Mul(&result, t0)

		// Step 70: &result = x^0x78383f2600000000
		result.nSquareCompressed(33)
		result.DecompressKarabina(&result)

		// Step 71: &result = x^0x78383f2600000001
		z.Mul(x, &result)

		return z.Conjugate(z)
	*/
	return z.Exp(*x, &xGen)
}

// MulBy014 multiplication by sparse element (c0, c1, 0, 0, c4)
func (z *E12) MulBy014(c0, c1, c4 *E2) *E12 {

	var a, b E6
	var d E2

	a.Set(&z.C0)
	a.MulBy01(c0, c1)

	b.Set(&z.C1)
	b.MulBy1(c4)
	d.Add(c1, c4)

	z.C1.Add(&z.C1, &z.C0)
	z.C1.MulBy01(c0, &d)
	z.C1.Sub(&z.C1, &a)
	z.C1.Sub(&z.C1, &b)
	z.C0.MulByNonResidue(&b)
	z.C0.Add(&z.C0, &a)

	return z
}

// MulBy01 multiplication by sparse element (c0, c1, 0, 0, 1)
func (z *E12) MulBy01(c0, c1 *E2) *E12 {

	var a, b E6
	var d E2

	a.Set(&z.C0)
	a.MulBy01(c0, c1)

	b.MulByNonResidue(&z.C1)
	d.SetOne().Add(c1, &d)

	z.C1.Add(&z.C1, &z.C0)
	z.C1.MulBy01(c0, &d)
	z.C1.Sub(&z.C1, &a)
	z.C1.Sub(&z.C1, &b)
	z.C0.MulByNonResidue(&b)
	z.C0.Add(&z.C0, &a)

	return z
}

// Mul014By014 multiplication of sparse element (c0,c1,0,0,c4,0) by sparse element (d0,d1,0,0,d4,0)
func Mul014By014(d0, d1, d4, c0, c1, c4 *E2) [5]E2 {
	var z00, tmp, x0, x1, x4, x04, x01, x14 E2
	x0.Mul(c0, d0)
	x1.Mul(c1, d1)
	x4.Mul(c4, d4)
	tmp.Add(c0, c4)
	x04.Add(d0, d4).
		Mul(&x04, &tmp).
		Sub(&x04, &x0).
		Sub(&x04, &x4)
	tmp.Add(c0, c1)
	x01.Add(d0, d1).
		Mul(&x01, &tmp).
		Sub(&x01, &x0).
		Sub(&x01, &x1)
	tmp.Add(c1, c4)
	x14.Add(d1, d4).
		Mul(&x14, &tmp).
		Sub(&x14, &x1).
		Sub(&x14, &x4)

	z00.MulByNonResidue(&x4).
		Add(&z00, &x0)

	return [5]E2{z00, x01, x1, x04, x14}
}

// Mul01By01 multiplication of sparse element (c0,c1,0,0,1,0) by sparse element (d0,d1,0,0,1,0)
func Mul01By01(d0, d1, c0, c1 *E2) [5]E2 {
	var z00, tmp, x0, x1, x4, x04, x01, x14 E2
	x0.Mul(c0, d0)
	x1.Mul(c1, d1)
	x4.SetOne()
	x04.Add(d0, c0)
	tmp.Add(c0, c1)
	x01.Add(d0, d1).
		Mul(&x01, &tmp).
		Sub(&x01, &x0).
		Sub(&x01, &x1)
	x14.Add(d1, c1)

	z00.MulByNonResidue(&x4).
		Add(&z00, &x0)

	return [5]E2{z00, x01, x1, x04, x14}
}

// MulBy01245 multiplies z by an E12 sparse element of the form (x0, x1, x2, 0, x4, x5)
func (z *E12) MulBy01245(x *[5]E2) *E12 {
	var c1, a, b, c, z0, z1 E6
	c0 := &E6{B0: x[0], B1: x[1], B2: x[2]}
	c1.B1 = x[3]
	c1.B2 = x[4]
	a.Add(&z.C0, &z.C1)
	b.Add(c0, &c1)
	a.Mul(&a, &b)
	b.Mul(&z.C0, c0)
	c.Set(&z.C1).MulBy12(&x[3], &x[4])
	z1.Sub(&a, &b)
	z1.Sub(&z1, &c)
	z0.MulByNonResidue(&c)
	z0.Add(&z0, &b)

	z.C0 = z0
	z.C1 = z1

	return z
}
