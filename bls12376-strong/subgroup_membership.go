package bls12376strong

import (
	"crypto/rand"
	"sync/atomic"
	"unsafe"

	"github.com/yelhousni/batch-subgroup-membership/bls12376-strong/fp"
	"github.com/yelhousni/batch-subgroup-membership/parallel"
)

// IsInSubGroupBatchNaive checks if a batch of points P_i are in G1.
// This is a naive method that checks each point individually using Scott test
// [Scott21].
//
// [Scott21]: https://eprint.iacr.org/2021/1130.pdf
func IsInSubGroupBatchNaive(points []G1Affine) bool {
	for i := range points {
		if !points[i].IsInSubGroup() {
			return false
		}
	}
	return true
}

func IsInSubGroupBatchNaiveParallel(points []G1Affine) bool {
	var nbErrors int64
	parallel.Execute(len(points), func(start, end int) {
		for i := start; i < end; i++ {
			if !points[i].IsInSubGroup() {
				atomic.AddInt64(&nbErrors, 1)
				return
			}
		}
	})
	return nbErrors == 0
}

// IsInSubGroupBatch checks if a batch of points P_i are in G1.
// First, it checks that all points are on a larger torsion E[r*e'] using Tate
// pairings [Koshelev22].
// Second, it generates random scalars s_i in the range [0, 2^60[, performs
// n=rounds multi-scalar-multiplication Sj=∑[s_i]P_i of sizes N=len(points) and
// checks if Sj are on E[r] using Scott test [Scott21].
//
// [Koshelev22]: https://eprint.iacr.org/2022/037.pdf
// [Scott21]: https://eprint.iacr.org/2021/1130.pdf
func IsInSubGroupBatch(points []G1Affine, rounds int) bool {

	// 1. Check points are on E[r*e']
	for i := range points {
		// 1.1. Tate_{2,P2}(Q) == Tate_{2,P2'}(Q) == 1, with P2 and P2' a basis of E[2].
		if !isFirstTateOne(points[i]) {
			return false
		}
		// 1.2. Tate_{3,P3}(Q) == 1, with P3 of order 3.
		if !isSecondTateOne(points[i]) {
			return false
		}
	}

	// 2. Check S1 is on E[r]
	return _msmCheck(points)
}

func IsInSubGroupBatchParallel(points []G1Affine, rounds int) bool {

	// 1. Check points are on E[r*e']
	var nbErrors int64
	parallel.Execute(len(points), func(start, end int) {
		for i := start; i < end; i++ {
			// 1.1. Tate_{2,P2}(Q) == Tate_{2,P2'}(Q) == 1, with P2 and P2' a basis of E[2].
			if !isFirstTateOne(points[i]) {
				atomic.AddInt64(&nbErrors, 1)
				return
			}
			// 1.2. Tate_{3,P3}(Q) == 1, with P3 of order 3.
			if !isSecondTateOne(points[i]) {
				atomic.AddInt64(&nbErrors, 1)
				return
			}
		}
	})
	if nbErrors > 0 {
		return false
	}

	// 2. Check S1 is on E[r]
	return _msmCheck(points)
}

// ---- Tate pairings ----
// isFirstTateOne checks that:
//
//	Tate_{2,P2}(Q) = (x+1)^((p-1)/2) == 1
//	Tate_{2,P2'}(Q) = (x+ω)^((p-1)/2) == 1 with ω^3 = 1 mod p.
//
// where P2 = (-1,0) and P2' = (-ω,0) are points of order 2 on the curve.
func isFirstTateOne(point G1Affine) bool {
	var tate1, tate2, one fp.Element
	one.SetOne()
	tate1.Add(&point.X, &one)
	tate2.Add(&point.X, &thirdRootOneG1)
	return tate1.Legendre() == 1 && tate2.Legendre() == 1
}

// isSecondTateOne checks that Tate_{3,P3}(Q) = (y-1)^((p-1)/3) == 1
// where P3 = (0,1) a point of order 3 on the curve
func isSecondTateOne(point G1Affine) bool {
	var tate, one fp.Element
	one.SetOne()
	tate.Sub(&point.Y, &one)
	tate = *expByp3(&tate)
	return tate.IsOne()
}

// expByp3 uses a short addition chain to compute x^p3 where p3=(p-1)/3 .
func expByp3(x *fp.Element) *fp.Element {
	// Operations: 368 squares 80 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var z = new(fp.Element)
	var (
		t0  = new(fp.Element)
		t1  = new(fp.Element)
		t2  = new(fp.Element)
		t3  = new(fp.Element)
		t4  = new(fp.Element)
		t5  = new(fp.Element)
		t6  = new(fp.Element)
		t7  = new(fp.Element)
		t8  = new(fp.Element)
		t9  = new(fp.Element)
		t10 = new(fp.Element)
		t11 = new(fp.Element)
		t12 = new(fp.Element)
		t13 = new(fp.Element)
		t14 = new(fp.Element)
		t15 = new(fp.Element)
		t16 = new(fp.Element)
		t17 = new(fp.Element)
		t18 = new(fp.Element)
		t19 = new(fp.Element)
		t20 = new(fp.Element)
		t21 = new(fp.Element)
		t22 = new(fp.Element)
		t23 = new(fp.Element)
		t24 = new(fp.Element)
		t25 = new(fp.Element)
		t26 = new(fp.Element)
		t27 = new(fp.Element)
		t28 = new(fp.Element)
		t29 = new(fp.Element)
		t30 = new(fp.Element)
		t31 = new(fp.Element)
		t32 = new(fp.Element)
	)

	// Step 1: t10 = x^0x2
	t10.Square(x)

	// Step 2: t7 = x^0x4
	t7.Square(t10)

	// Step 3: z = x^0x6
	z.Mul(t10, t7)

	// Step 4: t5 = x^0x8
	t5.Mul(t10, z)

	// Step 5: t4 = x^0xa
	t4.Mul(t10, t5)

	// Step 6: t2 = x^0x10
	t2.Mul(z, t4)

	// Step 7: t29 = x^0x12
	t29.Mul(t10, t2)

	// Step 8: t1 = x^0x13
	t1.Mul(x, t29)

	// Step 9: t27 = x^0x1b
	t27.Mul(t5, t1)

	// Step 10: t15 = x^0x23
	t15.Mul(t5, t27)

	// Step 11: t14 = x^0x27
	t14.Mul(t7, t15)

	// Step 12: t24 = x^0x2d
	t24.Mul(z, t14)

	// Step 13: t3 = x^0x2f
	t3.Mul(t10, t24)

	// Step 14: t9 = x^0x36
	t9.Mul(t1, t15)

	// Step 15: t20 = x^0x39
	t20.Mul(t4, t3)

	// Step 16: t8 = x^0x3d
	t8.Mul(t7, t20)

	// Step 17: t19 = x^0x43
	t19.Mul(z, t8)

	// Step 18: t6 = x^0x45
	t6.Mul(t10, t19)

	// Step 19: t0 = x^0x47
	t0.Mul(t10, t6)

	// Step 20: t28 = x^0x4f
	t28.Mul(t5, t0)

	// Step 21: t12 = x^0x53
	t12.Mul(t7, t28)

	// Step 22: t30 = x^0x89
	t30.Mul(t9, t12)

	// Step 23: t23 = x^0x8b
	t23.Mul(t10, t30)

	// Step 24: t9 = x^0x93
	t9.Mul(t5, t23)

	// Step 25: t11 = x^0x97
	t11.Mul(t7, t9)

	// Step 26: t26 = x^0xa3
	t26.Mul(t2, t9)

	// Step 27: t16 = x^0xa7
	t16.Mul(t7, t26)

	// Step 28: t5 = x^0xb1
	t5.Mul(t4, t16)

	// Step 29: t21 = x^0xb5
	t21.Mul(t7, t5)

	// Step 30: t18 = x^0xc5
	t18.Mul(t2, t21)

	// Step 31: t25 = x^0xc7
	t25.Mul(t10, t18)

	// Step 32: t31 = x^0xcd
	t31.Mul(z, t25)

	// Step 33: t2 = x^0xcf
	t2.Mul(t10, t31)

	// Step 34: t17 = x^0xd3
	t17.Mul(t7, t2)

	// Step 35: t4 = x^0xd5
	t4.Mul(t10, t17)

	// Step 36: t13 = x^0xe1
	t13.Mul(t29, t2)

	// Step 37: z = x^0xe3
	z.Mul(t10, t13)

	// Step 38: t10 = x^0xe5
	t10.Mul(t10, z)

	// Step 39: t22 = x^0xe9
	t22.Mul(t7, t10)

	// Step 40: t7 = x^0xed
	t7.Mul(t7, t22)

	// Step 41: t32 = x^0x138
	t32.Mul(t28, t22)

	// Step 50: t32 = x^0x27000
	for s := 0; s < 9; s++ {
		t32.Square(t32)
	}

	// Step 51: t31 = x^0x270cd
	t31.Mul(t31, t32)

	// Step 60: t31 = x^0x4e19a00
	for s := 0; s < 9; s++ {
		t31.Square(t31)
	}

	// Step 61: t31 = x^0x4e19a23
	t31.Mul(t15, t31)

	// Step 73: t31 = x^0x4e19a23000
	for s := 0; s < 12; s++ {
		t31.Square(t31)
	}

	// Step 74: t30 = x^0x4e19a23089
	t30.Mul(t30, t31)

	// Step 83: t30 = x^0x9c3344611200
	for s := 0; s < 9; s++ {
		t30.Square(t30)
	}

	// Step 84: t29 = x^0x9c3344611212
	t29.Mul(t29, t30)

	// Step 85: t29 = x^0x9c33446112ff
	t29.Mul(t7, t29)

	// Step 95: t29 = x^0x270cd11844bfc00
	for s := 0; s < 10; s++ {
		t29.Square(t29)
	}

	// Step 96: t28 = x^0x270cd11844bfc4f
	t28.Mul(t28, t29)

	// Step 105: t28 = x^0x4e19a230897f89e00
	for s := 0; s < 9; s++ {
		t28.Square(t28)
	}

	// Step 106: t27 = x^0x4e19a230897f89e1b
	t27.Mul(t27, t28)

	// Step 117: t27 = x^0x270cd11844bfc4f0d800
	for s := 0; s < 11; s++ {
		t27.Square(t27)
	}

	// Step 118: t26 = x^0x270cd11844bfc4f0d8a3
	t26.Mul(t26, t27)

	// Step 124: t26 = x^0x9c33446112ff13c3628c0
	for s := 0; s < 6; s++ {
		t26.Square(t26)
	}

	// Step 125: t26 = x^0x9c33446112ff13c3628f9
	t26.Mul(t20, t26)

	// Step 136: t26 = x^0x4e19a230897f89e1b147c800
	for s := 0; s < 11; s++ {
		t26.Square(t26)
	}

	// Step 137: t25 = x^0x4e19a230897f89e1b147c8c7
	t25.Mul(t25, t26)

	// Step 146: t25 = x^0x9c33446112ff13c3628f918e00
	for s := 0; s < 9; s++ {
		t25.Square(t25)
	}

	// Step 147: t25 = x^0x9c33446112ff13c3628f918ec5
	t25.Mul(t18, t25)

	// Step 155: t25 = x^0x9c33446112ff13c3628f918ec500
	for s := 0; s < 8; s++ {
		t25.Square(t25)
	}

	// Step 156: t24 = x^0x9c33446112ff13c3628f918ec52d
	t24.Mul(t24, t25)

	// Step 170: t24 = x^0x270cd11844bfc4f0d8a3e463b14b4000
	for s := 0; s < 14; s++ {
		t24.Square(t24)
	}

	// Step 171: t23 = x^0x270cd11844bfc4f0d8a3e463b14b408b
	t23.Mul(t23, t24)

	// Step 180: t23 = x^0x4e19a230897f89e1b147c8c76296811600
	for s := 0; s < 9; s++ {
		t23.Square(t23)
	}

	// Step 181: t22 = x^0x4e19a230897f89e1b147c8c762968116e9
	t22.Mul(t22, t23)

	// Step 187: t22 = x^0x1386688c225fe2786c51f231d8a5a045ba40
	for s := 0; s < 6; s++ {
		t22.Square(t22)
	}

	// Step 188: t22 = x^0x1386688c225fe2786c51f231d8a5a045ba67
	t22.Mul(t14, t22)

	// Step 199: t22 = x^0x9c33446112ff13c3628f918ec52d022dd33800
	for s := 0; s < 11; s++ {
		t22.Square(t22)
	}

	// Step 200: t21 = x^0x9c33446112ff13c3628f918ec52d022dd338b5
	t21.Mul(t21, t22)

	// Step 206: t21 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d40
	for s := 0; s < 6; s++ {
		t21.Square(t21)
	}

	// Step 207: t20 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d79
	t20.Mul(t20, t21)

	// Step 216: t20 = x^0x4e19a230897f89e1b147c8c762968116e99c5af200
	for s := 0; s < 9; s++ {
		t20.Square(t20)
	}

	// Step 217: t19 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243
	t19.Mul(t19, t20)

	// Step 227: t19 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90c00
	for s := 0; s < 10; s++ {
		t19.Square(t19)
	}

	// Step 228: t18 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc5
	t18.Mul(t18, t19)

	// Step 237: t18 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198a00
	for s := 0; s < 9; s++ {
		t18.Square(t18)
	}

	// Step 238: t17 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3
	t17.Mul(t17, t18)

	// Step 246: t17 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad300
	for s := 0; s < 8; s++ {
		t17.Square(t17)
	}

	// Step 247: t16 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a7
	t16.Mul(t16, t17)

	// Step 253: t16 = x^0x9c33446112ff13c3628f918ec52d022dd338b5e48662b4e9c0
	for s := 0; s < 6; s++ {
		t16.Square(t16)
	}

	// Step 254: t15 = x^0x9c33446112ff13c3628f918ec52d022dd338b5e48662b4e9e3
	t15.Mul(t15, t16)

	// Step 265: t15 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f1800
	for s := 0; s < 11; s++ {
		t15.Square(t15)
	}

	// Step 266: t14 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f1827
	t14.Mul(t14, t15)

	// Step 278: t14 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f1827000
	for s := 0; s < 12; s++ {
		t14.Square(t14)
	}

	// Step 279: t13 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e1
	t13.Mul(t13, t14)

	// Step 286: t13 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c1387080
	for s := 0; s < 7; s++ {
		t13.Square(t13)
	}

	// Step 287: t13 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c5
	t13.Mul(t6, t13)

	// Step 296: t13 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a00
	for s := 0; s < 9; s++ {
		t13.Square(t13)
	}

	// Step 297: t12 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a53
	t12.Mul(t12, t13)

	// Step 308: t12 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529800
	for s := 0; s < 11; s++ {
		t12.Square(t12)
	}

	// Step 309: t11 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897
	t11.Mul(t11, t12)

	// Step 317: t11 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c52989700
	for s := 0; s < 8; s++ {
		t11.Square(t11)
	}

	// Step 318: t10 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e5
	t10.Mul(t10, t11)

	// Step 326: t10 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e500
	for s := 0; s < 8; s++ {
		t10.Square(t10)
	}

	// Step 327: t9 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e593
	t9.Mul(t9, t10)

	// Step 339: t9 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e593000
	for s := 0; s < 12; s++ {
		t9.Square(t9)
	}

	// Step 340: t8 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d
	t8.Mul(t8, t9)

	// Step 351: t8 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e800
	for s := 0; s < 11; s++ {
		t8.Square(t8)
	}

	// Step 352: t7 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed
	t7.Mul(t7, t8)

	// Step 360: t7 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed00
	for s := 0; s < 8; s++ {
		t7.Square(t7)
	}

	// Step 361: t6 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed45
	t6.Mul(t6, t7)

	// Step 370: t6 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d1da8a00
	for s := 0; s < 9; s++ {
		t6.Square(t6)
	}

	// Step 371: t5 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d1da8ab1
	t5.Mul(t5, t6)

	// Step 380: t5 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a5312fcb2607a3b5156200
	for s := 0; s < 9; s++ {
		t5.Square(t5)
	}

	// Step 381: t4 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a5312fcb2607a3b51562d5
	t4.Mul(t4, t5)

	// Step 387: t4 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed4558b540
	for s := 0; s < 6; s++ {
		t4.Square(t4)
	}

	// Step 388: t3 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed4558b56f
	t3.Mul(t3, t4)

	// Step 399: t3 = x^0x9c33446112ff13c3628f918ec52d022dd338b5e48662b4e9e304e1c314a625f964c0f476a2ac5ab7800
	for s := 0; s < 11; s++ {
		t3.Square(t3)
	}

	// Step 400: t2 = x^0x9c33446112ff13c3628f918ec52d022dd338b5e48662b4e9e304e1c314a625f964c0f476a2ac5ab78cf
	t2.Mul(t2, t3)

	// Step 412: t2 = x^0x9c33446112ff13c3628f918ec52d022dd338b5e48662b4e9e304e1c314a625f964c0f476a2ac5ab78cf000
	for s := 0; s < 12; s++ {
		t2.Square(t2)
	}

	// Step 413: t1 = x^0x9c33446112ff13c3628f918ec52d022dd338b5e48662b4e9e304e1c314a625f964c0f476a2ac5ab78cf013
	t1.Mul(t1, t2)

	// Step 424: t1 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a5312fcb2607a3b51562d5bc67809800
	for s := 0; s < 11; s++ {
		t1.Square(t1)
	}

	// Step 425: t1 = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a5312fcb2607a3b51562d5bc678098e3
	t1.Mul(z, t1)

	// Step 432: t1 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d1da8ab16ade33c04c7180
	for s := 0; s < 7; s++ {
		t1.Square(t1)
	}

	// Step 433: t0 = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d1da8ab16ade33c04c71c7
	t0.Mul(t0, t1)

	// Step 444: t0 = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed4558b56f19e02638e3800
	for s := 0; s < 11; s++ {
		t0.Square(t0)
	}

	// Step 445: z = x^0x1386688c225fe2786c51f231d8a5a045ba6716bc90cc569d3c609c386294c4bf2c981e8ed4558b56f19e02638e38e3
	z.Mul(z, t0)

	// Step 446: z = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d1da8ab16ade33c04c71c71c6
	z.Square(z)

	// Step 447: z = x^0x270cd11844bfc4f0d8a3e463b14b408b74ce2d792198ad3a78c13870c529897e59303d1da8ab16ade33c04c71c71c7
	z.Mul(x, z)

	// Step 448: z = x^0x4e19a230897f89e1b147c8c762968116e99c5af243315a74f18270e18a5312fcb2607a3b51562d5bc678098e38e38e
	z.Square(z)

	return z
}

// ---- MSM ----
func _msmCheck(points []G1Affine) bool {
	const nbBitsBounds = 61
	const c = 6
	const nbChunks = 11 //(nbBitsBounds + c - 1) / c

	// for each chunk, spawn one go routine that'll loop through all the scalars in the
	// corresponding bit-window
	// note that buckets is an array allocated on the stack and this is critical for performance

	// each go routine sends its result in chChunks[i] channel
	chChunks := make([]chan g1JacExtended, nbChunks)
	for i := 0; i < len(chChunks); i++ {
		chChunks[i] = make(chan g1JacExtended, 1)
	}

	for j := int(nbChunks - 1); j >= 0; j-- {
		go processChunkG1Simplified[bucketg1JacExtendedC6](uint64(j), chChunks[j], c, points)
	}

	var p G1Jac
	msmReduceChunkG1Affine(&p, int(c), chChunks[:])

	return p.IsInSubGroup()
}

func processChunkG1Simplified[B bucketg1JacExtendedC6](chunk uint64,
	chRes chan<- g1JacExtended,
	c uint64,
	points []G1Affine) {

	const windowSize = 1024
	var br [windowSize * 2]byte

	// interpret br as an array of uint16 of size windowSize/2
	randomScalars := (*[windowSize]uint16)(unsafe.Pointer(&br[0]))

	// we need a mask to get only the (c-1) lowest bits of each scalar
	mask := uint16((1 << (c - 1)) - 1)

	var buckets B
	for i := 0; i < len(buckets); i++ {
		buckets[i].SetInfinity()
	}

	// for each scalars, get the digit corresponding to the chunk we're processing.
	for i := range points {
		if i%windowSize == 0 {
			// fill the lowest c bits of each scalar with random bytes
			rand.Read(br[:]) // does not return an error, always fills br
		}
		digit := randomScalars[i%windowSize] & mask
		if digit == 0 {
			continue
		}
		buckets[digit-1].addMixed(&points[i])
	}

	// reduce buckets into total
	// total =  bucket[0] + 2*bucket[1] + 3*bucket[2] ... + n*bucket[n-1]

	var runningSum, total g1JacExtended
	runningSum.SetInfinity()
	total.SetInfinity()
	for k := len(buckets) - 1; k >= 0; k-- {
		if !buckets[k].IsInfinity() {
			runningSum.add(&buckets[k])
		}
		total.add(&runningSum)
	}

	chRes <- total
}
